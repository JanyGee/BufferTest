// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im_proto_common.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "ImProtoCommon.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImProtoCommonRoot

@implementation ImProtoCommonRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ImProtoCommonRoot_FileDescriptor

static GPBFileDescriptor *ImProtoCommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum UpdateType

GPBEnumDescriptor *UpdateType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UpdateFriendInvite\000UpdateGroupInvite\000Upd"
        "ateFriendInfo\000UpdateGroupInfo\000UpdateDisc"
        "ussionInfo\000UpdateAddressBookInfo\000";
    static const int32_t values[] = {
        UpdateType_UpdateFriendInvite,
        UpdateType_UpdateGroupInvite,
        UpdateType_UpdateFriendInfo,
        UpdateType_UpdateGroupInfo,
        UpdateType_UpdateDiscussionInfo,
        UpdateType_UpdateAddressBookInfo,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UpdateType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UpdateType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UpdateType_IsValidValue(int32_t value__) {
  switch (value__) {
    case UpdateType_UpdateFriendInvite:
    case UpdateType_UpdateGroupInvite:
    case UpdateType_UpdateFriendInfo:
    case UpdateType_UpdateGroupInfo:
    case UpdateType_UpdateDiscussionInfo:
    case UpdateType_UpdateAddressBookInfo:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MsgType

GPBEnumDescriptor *MsgType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "MsgText\000MsgAudioBrief\000MsgAudioComplete\000M"
        "sgPicBrief\000MsgPicComplete\000MsgSys\000MsgGame"
        "\000MsgUpdate\000MsgGameresult\000";
    static const int32_t values[] = {
        MsgType_MsgText,
        MsgType_MsgAudioBrief,
        MsgType_MsgAudioComplete,
        MsgType_MsgPicBrief,
        MsgType_MsgPicComplete,
        MsgType_MsgSys,
        MsgType_MsgGame,
        MsgType_MsgUpdate,
        MsgType_MsgGameresult,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MsgType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MsgType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MsgType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MsgType_MsgText:
    case MsgType_MsgAudioBrief:
    case MsgType_MsgAudioComplete:
    case MsgType_MsgPicBrief:
    case MsgType_MsgPicComplete:
    case MsgType_MsgSys:
    case MsgType_MsgGame:
    case MsgType_MsgUpdate:
    case MsgType_MsgGameresult:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum IDType

GPBEnumDescriptor *IDType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IdSingle\000IdGroup\000IdDiscussion\000";
    static const int32_t values[] = {
        IDType_IdSingle,
        IDType_IdGroup,
        IDType_IdDiscussion,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(IDType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:IDType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL IDType_IsValidValue(int32_t value__) {
  switch (value__) {
    case IDType_IdSingle:
    case IDType_IdGroup:
    case IDType_IdDiscussion:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum FormatType

GPBEnumDescriptor *FormatType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "FormatProto\000FormatJson\000FormatXml\000";
    static const int32_t values[] = {
        FormatType_FormatProto,
        FormatType_FormatJson,
        FormatType_FormatXml,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(FormatType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:FormatType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL FormatType_IsValidValue(int32_t value__) {
  switch (value__) {
    case FormatType_FormatProto:
    case FormatType_FormatJson:
    case FormatType_FormatXml:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum EncryptMethod

GPBEnumDescriptor *EncryptMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "EncryptNone\000EncryptDes\000EncryptTea\000Encryp"
        "tAes\000";
    static const int32_t values[] = {
        EncryptMethod_EncryptNone,
        EncryptMethod_EncryptDes,
        EncryptMethod_EncryptTea,
        EncryptMethod_EncryptAes,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(EncryptMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:EncryptMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL EncryptMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case EncryptMethod_EncryptNone:
    case EncryptMethod_EncryptDes:
    case EncryptMethod_EncryptTea:
    case EncryptMethod_EncryptAes:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum UserOnOffline

GPBEnumDescriptor *UserOnOffline_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Offline\000Online\000";
    static const int32_t values[] = {
        UserOnOffline_Offline,
        UserOnOffline_Online,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(UserOnOffline)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:UserOnOffline_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL UserOnOffline_IsValidValue(int32_t value__) {
  switch (value__) {
    case UserOnOffline_Offline:
    case UserOnOffline_Online:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResultID

GPBEnumDescriptor *ResultID_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ResultSuccess\000ResultForbit\000ResultFail\000Re"
        "sultGetfriendlistError\000ResultUseroffline"
        "\000ResultAlreadyFriend\000ResultNotFriend\000";
    static const int32_t values[] = {
        ResultID_ResultSuccess,
        ResultID_ResultForbit,
        ResultID_ResultFail,
        ResultID_ResultGetfriendlistError,
        ResultID_ResultUseroffline,
        ResultID_ResultAlreadyFriend,
        ResultID_ResultNotFriend,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResultID)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResultID_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResultID_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResultID_ResultSuccess:
    case ResultID_ResultForbit:
    case ResultID_ResultFail:
    case ResultID_ResultGetfriendlistError:
    case ResultID_ResultUseroffline:
    case ResultID_ResultAlreadyFriend:
    case ResultID_ResultNotFriend:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RegisterStatus

GPBEnumDescriptor *RegisterStatus_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "RegisterNone\000RegisterAlready\000";
    static const int32_t values[] = {
        RegisterStatus_RegisterNone,
        RegisterStatus_RegisterAlready,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RegisterStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RegisterStatus_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RegisterStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case RegisterStatus_RegisterNone:
    case RegisterStatus_RegisterAlready:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MessageHead

@implementation MessageHead

@dynamic hasClientVersion, clientVersion;
@dynamic hasCid, cid;
@dynamic hasBodyMessageFormat, bodyMessageFormat;
@dynamic hasEncryptMethod, encryptMethod;
@dynamic hasMessageBodyName, messageBodyName;

typedef struct MessageHead__storage_ {
  uint32_t _has_storage_[1];
  int32_t clientVersion;
  int32_t cid;
  FormatType bodyMessageFormat;
  EncryptMethod encryptMethod;
  NSString *messageBodyName;
} MessageHead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_ClientVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageHead__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageHead__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bodyMessageFormat",
        .dataTypeSpecific.enumDescFunc = FormatType_EnumDescriptor,
        .number = MessageHead_FieldNumber_BodyMessageFormat,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageHead__storage_, bodyMessageFormat),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "encryptMethod",
        .dataTypeSpecific.enumDescFunc = EncryptMethod_EnumDescriptor,
        .number = MessageHead_FieldNumber_EncryptMethod,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageHead__storage_, encryptMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "messageBodyName",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_MessageBodyName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MessageHead__storage_, messageBodyName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageHead class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageHead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMessage

@implementation IMMessage

@dynamic hasMessageHead, messageHead;
@dynamic hasMessageBody, messageBody;

typedef struct IMMessage__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
  NSData *messageBody;
} IMMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = IMMessage_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMessage__storage_, messageHead),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "messageBody",
        .dataTypeSpecific.className = NULL,
        .number = IMMessage_FieldNumber_MessageBody,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMessage__storage_, messageBody),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMessage class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMessageResponse

@implementation IMMessageResponse

@dynamic hasResult, result;
@dynamic hasResultInfo, resultInfo;

typedef struct IMMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  ResultID result;
  NSString *resultInfo;
} IMMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResultID_EnumDescriptor,
        .number = IMMessageResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IMMessageResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "resultInfo",
        .dataTypeSpecific.className = NULL,
        .number = IMMessageResponse_FieldNumber_ResultInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IMMessageResponse__storage_, resultInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMessageResponse class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IMMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgUserBriefInfo

@implementation MsgUserBriefInfo

@dynamic hasCid, cid;
@dynamic hasIdType, idType;
@dynamic hasExtInfo, extInfo;

typedef struct MsgUserBriefInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t cid;
  IDType idType;
  NSString *extInfo;
} MsgUserBriefInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = MsgUserBriefInfo_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgUserBriefInfo__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "idType",
        .dataTypeSpecific.enumDescFunc = IDType_EnumDescriptor,
        .number = MsgUserBriefInfo_FieldNumber_IdType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgUserBriefInfo__storage_, idType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "extInfo",
        .dataTypeSpecific.className = NULL,
        .number = MsgUserBriefInfo_FieldNumber_ExtInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgUserBriefInfo__storage_, extInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgUserBriefInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgUserBriefInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MsgHead

@implementation MsgHead

@dynamic hasSourceUserinfo, sourceUserinfo;
@dynamic hasTargetUserinfo, targetUserinfo;
@dynamic hasMsgType, msgType;
@dynamic hasTimestamp, timestamp;
@dynamic hasSequence, sequence;

typedef struct MsgHead__storage_ {
  uint32_t _has_storage_[1];
  MsgType msgType;
  int32_t timestamp;
  MsgUserBriefInfo *sourceUserinfo;
  MsgUserBriefInfo *targetUserinfo;
  uint64_t sequence;
} MsgHead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceUserinfo",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgUserBriefInfo),
        .number = MsgHead_FieldNumber_SourceUserinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MsgHead__storage_, sourceUserinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "targetUserinfo",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgUserBriefInfo),
        .number = MsgHead_FieldNumber_TargetUserinfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MsgHead__storage_, targetUserinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.enumDescFunc = MsgType_EnumDescriptor,
        .number = MsgHead_FieldNumber_MsgType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MsgHead__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = MsgHead_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MsgHead__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = MsgHead_FieldNumber_Sequence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MsgHead__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MsgHead class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MsgHead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Msg

@implementation Msg

@dynamic hasMsgHead, msgHead;
@dynamic hasMsgInfo, msgInfo;
@dynamic hasRevInfo, revInfo;

typedef struct Msg__storage_ {
  uint32_t _has_storage_[1];
  MsgHead *msgHead;
  NSData *msgInfo;
  NSString *revInfo;
} Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgHead),
        .number = Msg_FieldNumber_MsgHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Msg__storage_, msgHead),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgInfo",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_MsgInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Msg__storage_, msgInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "revInfo",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_RevInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Msg__storage_, revInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Msg class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterRequest

@implementation RegisterRequest

@dynamic hasServerId, serverId;
@dynamic hasServerType, serverType;

typedef struct RegisterRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t serverId;
  int32_t serverType;
} RegisterRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverId",
        .dataTypeSpecific.className = NULL,
        .number = RegisterRequest_FieldNumber_ServerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterRequest__storage_, serverId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverType",
        .dataTypeSpecific.className = NULL,
        .number = RegisterRequest_FieldNumber_ServerType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterRequest__storage_, serverType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterRequest class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterResponse

@implementation RegisterResponse

@dynamic hasResult, result;

typedef struct RegisterResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t result;
} RegisterResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = RegisterResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterResponse__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterResponse class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SimpleUserInfo

@implementation SimpleUserInfo

@dynamic hasCid, cid;
@dynamic hasNickname, nickname;
@dynamic hasSex, sex;
@dynamic hasAvatarURL, avatarURL;

typedef struct SimpleUserInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t cid;
  NSString *nickname;
  NSString *sex;
  NSString *avatarURL;
} SimpleUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = SimpleUserInfo_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SimpleUserInfo__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = SimpleUserInfo_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SimpleUserInfo__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = SimpleUserInfo_FieldNumber_Sex,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SimpleUserInfo__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarURL",
        .dataTypeSpecific.className = NULL,
        .number = SimpleUserInfo_FieldNumber_AvatarURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SimpleUserInfo__storage_, avatarURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SimpleUserInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SimpleUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\004\006\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic hasSimpleUserinfo, simpleUserinfo;
@dynamic hasMid, mid;
@dynamic hasRegionid, regionid;
@dynamic hasClientVersion, clientVersion;
@dynamic hasCity, city;
@dynamic hasStatus, status;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t mid;
  int32_t regionid;
  int32_t clientVersion;
  UserOnOffline status;
  SimpleUserInfo *simpleUserinfo;
  NSString *city;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "simpleUserinfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SimpleUserInfo),
        .number = UserInfo_FieldNumber_SimpleUserinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, simpleUserinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Mid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfo__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regionid",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Regionid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfo__storage_, regionid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_ClientVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfo__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_City,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfo__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = UserOnOffline_EnumDescriptor,
        .number = UserInfo_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgReq

@implementation SendMsgReq

@dynamic hasMsgHead, msgHead;
@dynamic hasMsgInfo, msgInfo;
@dynamic hasSessionInfo, sessionInfo;
@dynamic hasNickName, nickName;

typedef struct SendMsgReq__storage_ {
  uint32_t _has_storage_[1];
  MsgHead *msgHead;
  NSData *msgInfo;
  NSString *sessionInfo;
  NSString *nickName;
} SendMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgHead),
        .number = SendMsgReq_FieldNumber_MsgHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgReq__storage_, msgHead),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgInfo",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgReq_FieldNumber_MsgInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsgReq__storage_, msgInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sessionInfo",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgReq_FieldNumber_SessionInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendMsgReq__storage_, sessionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgReq_FieldNumber_NickName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendMsgReq__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgReq class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgRes

@implementation SendMsgRes

@dynamic hasRes, res;
@dynamic hasSessionInfo, sessionInfo;

typedef struct SendMsgRes__storage_ {
  uint32_t _has_storage_[1];
  IMMessageResponse *res;
  NSString *sessionInfo;
} SendMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "res",
        .dataTypeSpecific.className = GPBStringifySymbol(IMMessageResponse),
        .number = SendMsgRes_FieldNumber_Res,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgRes__storage_, res),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionInfo",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgRes_FieldNumber_SessionInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsgRes__storage_, sessionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgRes class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMultiMsgReq

@implementation SendMultiMsgReq

@dynamic sendMsgArray, sendMsgArray_Count;

typedef struct SendMultiMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sendMsgArray;
} SendMultiMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sendMsgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SendMsgReq),
        .number = SendMultiMsgReq_FieldNumber_SendMsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMultiMsgReq__storage_, sendMsgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMultiMsgReq class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMultiMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncMsgPush

@implementation SyncMsgPush

@dynamic hasSyncNo, syncNo;
@dynamic hasInfo, info;

typedef struct SyncMsgPush__storage_ {
  uint32_t _has_storage_[1];
  NSString *info;
  uint64_t syncNo;
} SyncMsgPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "syncNo",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgPush_FieldNumber_SyncNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncMsgPush__storage_, syncNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgPush_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncMsgPush__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncMsgPush class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncMsgPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncMsgReq

@implementation SyncMsgReq

@dynamic hasSyncNo, syncNo;
@dynamic hasInfo, info;

typedef struct SyncMsgReq__storage_ {
  uint32_t _has_storage_[1];
  NSString *info;
  uint64_t syncNo;
} SyncMsgReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "syncNo",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgReq_FieldNumber_SyncNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, syncNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgReq_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncMsgReq__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncMsgReq class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncMsgReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncMsgRes

@implementation SyncMsgRes

@dynamic msgsArray, msgsArray_Count;
@dynamic hasSyncNo, syncNo;
@dynamic hasInfo, info;

typedef struct SyncMsgRes__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
  NSString *info;
  uint64_t syncNo;
} SyncMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PushMsg),
        .number = SyncMsgRes_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncMsgRes__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncNo",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgRes_FieldNumber_SyncNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncMsgRes__storage_, syncNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgRes_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncMsgRes__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncMsgRes class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncMsgAck

@implementation SyncMsgAck

@dynamic hasSyncNo, syncNo;
@dynamic hasInfo, info;

typedef struct SyncMsgAck__storage_ {
  uint32_t _has_storage_[1];
  NSString *info;
  uint64_t syncNo;
} SyncMsgAck__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "syncNo",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgAck_FieldNumber_SyncNo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncMsgAck__storage_, syncNo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "info",
        .dataTypeSpecific.className = NULL,
        .number = SyncMsgAck_FieldNumber_Info,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncMsgAck__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncMsgAck class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncMsgAck__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushMsg

@implementation PushMsg

@dynamic hasMsgHead, msgHead;
@dynamic hasMsgInfo, msgInfo;
@dynamic hasSessionInfo, sessionInfo;

typedef struct PushMsg__storage_ {
  uint32_t _has_storage_[1];
  MsgHead *msgHead;
  NSData *msgInfo;
  NSString *sessionInfo;
} PushMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MsgHead),
        .number = PushMsg_FieldNumber_MsgHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMsg__storage_, msgHead),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgInfo",
        .dataTypeSpecific.className = NULL,
        .number = PushMsg_FieldNumber_MsgInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushMsg__storage_, msgInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sessionInfo",
        .dataTypeSpecific.className = NULL,
        .number = PushMsg_FieldNumber_SessionInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushMsg__storage_, sessionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMsg class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushMsgRes

@implementation PushMsgRes

@dynamic hasResult, result;
@dynamic hasSessionInfo, sessionInfo;

typedef struct PushMsgRes__storage_ {
  uint32_t _has_storage_[1];
  ResultID result;
  NSString *sessionInfo;
} PushMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResultID_EnumDescriptor,
        .number = PushMsgRes_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMsgRes__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionInfo",
        .dataTypeSpecific.className = NULL,
        .number = PushMsgRes_FieldNumber_SessionInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushMsgRes__storage_, sessionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMsgRes class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushMultiMsg

@implementation PushMultiMsg

@dynamic pushMsgArray, pushMsgArray_Count;
@dynamic hasSessionInfo, sessionInfo;

typedef struct PushMultiMsg__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pushMsgArray;
  NSString *sessionInfo;
} PushMultiMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pushMsgArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PushMsg),
        .number = PushMultiMsg_FieldNumber_PushMsgArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PushMultiMsg__storage_, pushMsgArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionInfo",
        .dataTypeSpecific.className = NULL,
        .number = PushMultiMsg_FieldNumber_SessionInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMultiMsg__storage_, sessionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMultiMsg class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMultiMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushMultiMsgRes

@implementation PushMultiMsgRes

@dynamic hasResult, result;
@dynamic hasSessionInfo, sessionInfo;

typedef struct PushMultiMsgRes__storage_ {
  uint32_t _has_storage_[1];
  ResultID result;
  NSString *sessionInfo;
} PushMultiMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResultID_EnumDescriptor,
        .number = PushMultiMsgRes_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMultiMsgRes__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sessionInfo",
        .dataTypeSpecific.className = NULL,
        .number = PushMultiMsgRes_FieldNumber_SessionInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushMultiMsgRes__storage_, sessionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMultiMsgRes class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMultiMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TextMsgInfo

@implementation TextMsgInfo

@dynamic hasMsg, msg;

typedef struct TextMsgInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} TextMsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = TextMsgInfo_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMsgInfo__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMsgInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMsgInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioMsgBriefInfo

@implementation AudioMsgBriefInfo

@dynamic hasAudioLength, audioLength;
@dynamic hasAudioSize, audioSize;
@dynamic hasURL, URL;

typedef struct AudioMsgBriefInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t audioLength;
  int32_t audioSize;
  NSString *URL;
} AudioMsgBriefInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioLength",
        .dataTypeSpecific.className = NULL,
        .number = AudioMsgBriefInfo_FieldNumber_AudioLength,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioMsgBriefInfo__storage_, audioLength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "audioSize",
        .dataTypeSpecific.className = NULL,
        .number = AudioMsgBriefInfo_FieldNumber_AudioSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AudioMsgBriefInfo__storage_, audioSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AudioMsgBriefInfo_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AudioMsgBriefInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioMsgBriefInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioMsgBriefInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioMsgCompleteInfo

@implementation AudioMsgCompleteInfo

@dynamic hasBriefAudioInfo, briefAudioInfo;
@dynamic hasAudioData, audioData;

typedef struct AudioMsgCompleteInfo__storage_ {
  uint32_t _has_storage_[1];
  AudioMsgBriefInfo *briefAudioInfo;
  NSData *audioData;
} AudioMsgCompleteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "briefAudioInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(AudioMsgBriefInfo),
        .number = AudioMsgCompleteInfo_FieldNumber_BriefAudioInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioMsgCompleteInfo__storage_, briefAudioInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audioData",
        .dataTypeSpecific.className = NULL,
        .number = AudioMsgCompleteInfo_FieldNumber_AudioData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AudioMsgCompleteInfo__storage_, audioData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioMsgCompleteInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioMsgCompleteInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PicBriefInfo

@implementation PicBriefInfo

@dynamic hasPicSize, picSize;
@dynamic hasHeight, height;
@dynamic hasWidth, width;
@dynamic hasThumbleURL, thumbleURL;
@dynamic hasURL, URL;

typedef struct PicBriefInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t picSize;
  int32_t height;
  int32_t width;
  NSString *thumbleURL;
  NSString *URL;
} PicBriefInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "picSize",
        .dataTypeSpecific.className = NULL,
        .number = PicBriefInfo_FieldNumber_PicSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PicBriefInfo__storage_, picSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = PicBriefInfo_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PicBriefInfo__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = PicBriefInfo_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PicBriefInfo__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "thumbleURL",
        .dataTypeSpecific.className = NULL,
        .number = PicBriefInfo_FieldNumber_ThumbleURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PicBriefInfo__storage_, thumbleURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = PicBriefInfo_FieldNumber_URL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PicBriefInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PicBriefInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PicBriefInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\007\241!!\000\005!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PicCompleteInfo

@implementation PicCompleteInfo

@dynamic hasPicBriefInfo, picBriefInfo;
@dynamic hasPicData, picData;

typedef struct PicCompleteInfo__storage_ {
  uint32_t _has_storage_[1];
  PicBriefInfo *picBriefInfo;
  NSData *picData;
} PicCompleteInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "picBriefInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PicBriefInfo),
        .number = PicCompleteInfo_FieldNumber_PicBriefInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PicCompleteInfo__storage_, picBriefInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "picData",
        .dataTypeSpecific.className = NULL,
        .number = PicCompleteInfo_FieldNumber_PicData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PicCompleteInfo__storage_, picData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PicCompleteInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PicCompleteInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SystemMsgInfo

@implementation SystemMsgInfo

@dynamic hasMsg, msg;

typedef struct SystemMsgInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} SystemMsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = SystemMsgInfo_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SystemMsgInfo__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SystemMsgInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SystemMsgInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GameMsgInfo

@implementation GameMsgInfo

@dynamic hasGameData, gameData;

typedef struct GameMsgInfo__storage_ {
  uint32_t _has_storage_[1];
  NSData *gameData;
} GameMsgInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gameData",
        .dataTypeSpecific.className = NULL,
        .number = GameMsgInfo_FieldNumber_GameData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GameMsgInfo__storage_, gameData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GameMsgInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GameMsgInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserLoginReq

@implementation UserLoginReq

@dynamic hasClientVersion, clientVersion;
@dynamic hasSig, sig;
@dynamic hasExtInfo, extInfo;

typedef struct UserLoginReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t clientVersion;
  NSString *sig;
  NSString *extInfo;
} UserLoginReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginReq_FieldNumber_ClientVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLoginReq__storage_, clientVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sig",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginReq_FieldNumber_Sig,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserLoginReq__storage_, sig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extInfo",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginReq_FieldNumber_ExtInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserLoginReq__storage_, extInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLoginReq class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLoginReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserLoginRes

@implementation UserLoginRes

@dynamic hasResult, result;
@dynamic hasError, error;
@dynamic hasExtinfo, extinfo;

typedef struct UserLoginRes__storage_ {
  uint32_t _has_storage_[1];
  ResultID result;
  NSString *error;
  NSString *extinfo;
} UserLoginRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResultID_EnumDescriptor,
        .number = UserLoginRes_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserLoginRes__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginRes_FieldNumber_Error,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserLoginRes__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extinfo",
        .dataTypeSpecific.className = NULL,
        .number = UserLoginRes_FieldNumber_Extinfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserLoginRes__storage_, extinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserLoginRes class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserLoginRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HeartbeatRequest

@implementation HeartbeatRequest

@dynamic hasTime, time;

typedef struct HeartbeatRequest__storage_ {
  uint32_t _has_storage_[1];
  int64_t time;
} HeartbeatRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = HeartbeatRequest_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HeartbeatRequest__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HeartbeatRequest class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HeartbeatRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HeartbeatResponse

@implementation HeartbeatResponse

@dynamic hasResult, result;

typedef struct HeartbeatResponse__storage_ {
  uint32_t _has_storage_[1];
  ResultID result;
} HeartbeatResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = ResultID_EnumDescriptor,
        .number = HeartbeatResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HeartbeatResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HeartbeatResponse class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HeartbeatResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProxyMsg

@implementation ProxyMsg

@dynamic hasSourceId, sourceId;
@dynamic hasTargetId, targetId;
@dynamic hasMsg, msg;

typedef struct ProxyMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t sourceId;
  int32_t targetId;
  IMMessage *msg;
} ProxyMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sourceId",
        .dataTypeSpecific.className = NULL,
        .number = ProxyMsg_FieldNumber_SourceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProxyMsg__storage_, sourceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "targetId",
        .dataTypeSpecific.className = NULL,
        .number = ProxyMsg_FieldNumber_TargetId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProxyMsg__storage_, targetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = GPBStringifySymbol(IMMessage),
        .number = ProxyMsg_FieldNumber_Msg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProxyMsg__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProxyMsg class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProxyMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProxyMultiMsg

@implementation ProxyMultiMsg

@dynamic msgsArray, msgsArray_Count;

typedef struct ProxyMultiMsg__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *msgsArray;
} ProxyMultiMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ProxyMsg),
        .number = ProxyMultiMsg_FieldNumber_MsgsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ProxyMultiMsg__storage_, msgsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProxyMultiMsg class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProxyMultiMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProxyMultiMsgRes

@implementation ProxyMultiMsgRes

@dynamic hasRes, res;

typedef struct ProxyMultiMsgRes__storage_ {
  uint32_t _has_storage_[1];
  IMMessageResponse *res;
} ProxyMultiMsgRes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "res",
        .dataTypeSpecific.className = GPBStringifySymbol(IMMessageResponse),
        .number = ProxyMultiMsgRes_FieldNumber_Res,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProxyMultiMsgRes__storage_, res),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProxyMultiMsgRes class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProxyMultiMsgRes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyBekicked

@implementation NotifyBekicked

@dynamic hasTime, time;
@dynamic hasRemoteIp, remoteIp;

typedef struct NotifyBekicked__storage_ {
  uint32_t _has_storage_[1];
  NSString *remoteIp;
  int64_t time;
} NotifyBekicked__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = NotifyBekicked_FieldNumber_Time,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifyBekicked__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "remoteIp",
        .dataTypeSpecific.className = NULL,
        .number = NotifyBekicked_FieldNumber_RemoteIp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NotifyBekicked__storage_, remoteIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyBekicked class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifyBekicked__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateInfo

@implementation UpdateInfo

@dynamic hasUpdateParams, updateParams;
@dynamic hasUpdateType, updateType;

typedef struct UpdateInfo__storage_ {
  uint32_t _has_storage_[1];
  UpdateType updateType;
  NSString *updateParams;
} UpdateInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "updateParams",
        .dataTypeSpecific.className = NULL,
        .number = UpdateInfo_FieldNumber_UpdateParams,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateInfo__storage_, updateParams),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updateType",
        .dataTypeSpecific.enumDescFunc = UpdateType_EnumDescriptor,
        .number = UpdateInfo_FieldNumber_UpdateType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateInfo__storage_, updateType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateInfo class]
                                     rootClass:[ImProtoCommonRoot class]
                                          file:ImProtoCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
